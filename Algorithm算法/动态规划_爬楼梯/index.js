///////////////////////////////////////////////////////////////////////////////////////////
//  
//  动态规划_爬楼梯
//
//  动态规划的思想：
//
//  大事化小，小事化了，把一个复杂的问题分阶段进行简化，逐步化简成简单的问题
//
//  从后往前推算
//
//  假如爬到第n层是最后一步，则有两种方法爬到这
//  1. 在第(n-1)层时爬一步
//  2. 在第(n-2)层时爬两步
//
//  所以爬到第n层的方法数 = 爬到第(n-1)层的方法数 + 爬到第(n-2)层的方法数
//
//  得出公式：n层楼梯时：f(n) = f(n-1) + f(n-2)
//
//  给出f(0) = 0, f(1) = 1, f(2) = 2，就能算出f(n)的值了
//
//  当然也可以用递归做，我这里用的for循环
//
//  递归的坏处：耗费非常多的时间，时间复杂度将近O(2的N次幂)，因为有非常多的重复计算
//
//  使用for循环：创建一个数组，保留之前已计算过的值，当再次计算时直接拿出来用就行了，以空间换时间
//
//  --------------------------------------------------------------------------------
//
//  其实也可以从前往后推导
//
//  n = 1, f(n) = 1
//  n = 2, f(n) = 2
//  n = 3, f(n) = 3
//  n = 4, f(n) = 5
//  n = 5, f(n) = 8
//  n = 6, f(n) = 13
//  ...
//
//  这么明显的斐波那契数列 (后一项等于前两项之和)
//
//  其实还是有一点点不同的，完整的斐波那契数列前面有两个1
//
//  斐波那契：1，1，2，3，5，8，13...
//  
//////////////////////////////////////////////////////////////////////////////////////////

//  点击爬梯按钮 显示结果
function ClickButton() {
    var n = document.getElementById("numberInput").value;
    var result = ClimbStairs(n);
    document.getElementById("resultText").innerText = '一共有 ' + result + ' 种不同的方法爬到楼顶';
}

//  爬楼梯算法
function ClimbStairs(n) {
    var sum = [0, 1, 2];
    for (let i = 3; i <= n; i++) {
        sum[i] = sum[i - 1] + sum[i - 2];
    }
    return sum[n];
}